# 1장 타입스크립트 알아보기

## 타입스크립트는 사용 방식 면에서 독특한 언어
- 인터프리터(파이썬, 루비)로 실행되는 것도 X
- 저수준 언어로 컴파일(Java, C) X
- JS로 컴파일, 실행 역시 JS로 이루어짐.

따라서 JS와 필연적 관계로 혼란스러운 일이 벌어지기도 한다.

## 아이템 1: TS와 JS의 관계 이해하기

### TS는 문법적으로 JS의 상위집합(superset)
JS 프로그램에 문법 오류가 없다면, 유효한 TS 프로그램이라고 할 수 있다. but JS 프로그램에 어떤 이슈가 존재한다면 **문법 오류가 아니라도 타입 체커에게 지적당할 가능성 O**

but 문법의 유효성과 동작의 이슈는 독립적인 문제! TS는 여전히 작성된 코드를 파싱하고 JS로 변환가능.<br>
JS 파일이 .js(.jsx) 확장자를 사용하는 반면, TS는 .ts(.tsx) 확장자를 사용하지만 `JS와 TS는 완전히 다른 언어라는 의미 X`. TS는 JS의 superset이기 때문에 .js 파일에 있는 코드는 이미 TS라고 할 수 있다.

이러한 특성은 기존에 존재하는 JS 코드를 TS코드로 마이그레이션하는 데 엄청난 이점! 기존 코드를 그대로 유지하면서 일부분에만 TS 적용이 가능하기 때문.

**모든 JS 프로그램이 TS라는 명제는 O but 반대는 X.**
TS프로그램이지만 JS가 아닌 프로그램이 존재. 이는 TS가 타입을 명시하는 추가적인 문법을 가지기 때문.

### 타입 시스템의 목표 중 하나는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것
정적 타입 시스템이라는 것은 바로 이런 특징! but 타입 체커가 모든 오류를 찾아내지는 않는다.

오류가 발생하지는 않지만 의도와 다르게 동작하는 코드도 존재. TS는 이러한 문제 중 몇 가지를 찾아내기도 한다.

``` js
const states = { name, capital };
console.log(states.capitol);
// undefined
```
JS코드이며 어떠한 오류도 없이 실행된다. but `states.capitol`은 의도한 코드가 아닌게 분명하다. 이런 경우에 TS 타입 체커는 **추가적인 타입 구문 없이도 오류를 찾아낸다.(또한, 훌륭한 해결책을 제시.)**

TS는 타입 구문 없이도 오류를 잡을 수 있지만, _**타입 구문을 추가한다면 훨씬 더 많은 오류를 찾아낼 수 있다.**_ 코드의 `의도`가 무엇인지 타입 구문을 통해 TS에게 알려줄 수 있기 때문에 코드의 동작과 의도가 다른 부분을 찾을 수 있다.

여기서 capital과 capitol을 바꾸면 `capital 속성이 ...없습니다. capitol을 사용하시겠습니까?`와 같은 해결책을 제시한다. 하지만 해결책은 잘못되었다. **이처럼 TS는 어느 쪽이 오타인지 판단하지 못한다.** 오류의 원인을 추측할 수는 있겠지만 항상 정확하지는 않다. **따라서 명시적으로 states를 선언하여 의도를 분명하게 하는 것이 좋다.**

``` ts
interface States {
  name: string;
  capital: string;
}
```
이제 오류가 어디에서 발생했는지 찾을 수 있고, 제시된 해결책도 올바르다. 의도를 명확히 해서 TS가 잠재적 문제점을 찾을 수 있게 했다.

지금까지 내용을 정리하여 `TS는 JS의 superset이다.`라는 문장이 잘못된 것처럼 느껴진다면 `타입 체커를 통과한 TS 프로그램` 영역 때문일 것이다. 평소 작성하는 TS코드가 바로 이 영역에 해당한다. 보통은 타입 체크에서 오류가 발생하지 않도록 신경을 쓰며 TS 코드를 작성하기 때문이다.

### TS 타입 시스템은 JS 런타임 동작을 모델링한다.
``` js
const x = 2 + '3';
const y = '2' + 3;
```

이 예제는 다른 언어였다면 런타임 오류가 될 만한 코드이다. 하지만 TS의 타입 체커는 정상으로 인식한다. 두 줄 모두 문자열 "23"이 되는 JS 런타임 동작으로 모델링된다.

반대로 정상 동작하는 JS 코드에 오류를 표시하기도 한다. 런타임 오류가 발생하지 않는 코드인데, 타입 체커는 문제점을 표시한다.
``` js
const a = null + 7; // JS에서는 7
const b = [] + 12; // JS에서는 '12'
alert('Hello', 'TypeScript') // JS에서는 "Hello"표시
```

JS이 런타임 동작을 모델링하는 것은 TS 타입 시스템의 기본 원칙이다. 그러나 앞에서 봤던 경우들처럼 단순히 런타임 동작을 모델링하는 것뿐만 아니라 의도치 않은 이상한 오류로 이어질 수도 있다는 점까지 고려해야 한다.`(capital, capitol 예제)`

언제 JS 런타임 동작을 그대로 모델링할지, 또는 추가적인 타입 체크를 할지 분명하지 않다면 과연 TS를 사용해도 되는지 의문이 들 수 있다. TS 채택 여부는 사용자의 선택에 달려있지만 TS의 도움을 받으면 오류가 적은 코드를 작성할 수 있다.


## 아이템 2: TS 설정 이해하기
다음 코드가 오류 없이 타입 체커를 통과할 수 있을지 생각해 보겠습니다.
``` ts
function add(a, b) {
  return a + b;
}
add(10, null);
```

설정이 어떻게 되어 있는지 모른다면 대답할 수 없는 질문입니다. TS컴파일러는 매우 많은 설정을 갖고 있습니다. 현재 시점에서는 설정이 거의 100개에 이릅니다.<br>
이 설정들은 커맨드 라인에서 사용할 수 있습니다.<br>
`$ tsc --noImplicitAny program.ts`

`tsconfig.json` 설정 파일을 통해서도 가능합니다.
``` json
{
  "compilerOptions": {
    "noImplicitAny": true
  }
}
```
**가급적 설정 파일을 사용하는 것이 좋다.** 그래야만 TS를 어떻게 사용할 계획인지 동료들이나 다른 도구들이 알 수 있다. 설정 파일은 `tsc --init`만 실행하며 간단히 생성된다.

TS의 설정들은 어디서 소스 파일을 찾을지, 어떤 종류의 출력을 생성할지 제어하는 내용이 대부분. **그런데 언어 자체의 핵심 요소들을 제어하는 설정도 있다. 대부분의 언어에서는 허용하지 않는 고수준 설계의 설정이다.** 설정을 제대로 사용하려면, `noImplicitAny`와 `strictNullChecks`를 이해해야 한다.<br>

### noImplicitAny
`noImplicitAny`는 변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어한다. 위의 `add`코드는 `noImplicitAny`이 `false`일 때 유효하다.<br>
이 함수의 타입은 `function add(a: any, b: any): any`이다.<br>
any 타입을 매개변수에 사용하면 타입 체커는 속절없이 무력해진다. any는 유용하지만 매우 주의해서 사용해야 한다.

그런데 같은 코드임에도 `noImplicitAny`가 설정되었다면 오류가 된다. _이 오류들은 명시적으로 `: any`라고 선언해 주거나 더 분명한 타입을 사용하면 해결할 수 있다._
``` ts
function add(a: number, b: number) {
  return a + b;
}
```

TS는 타입 정보를 가질 때 가장 효과적이기 때문에, 되도록이면 `noImplicitAny`를 설정해야 한다. 그러면 TS가 문제를 발견하기 수월해지고, 코드의 가독성이 좋아지며, 개발자의 생산성이 향상된다. **참고로 `noImplicitAny` 해제는 JS로 되어 있는 기존 코드를 TS로 마이그레이션할 때에만 필요하다.**

### strictNullChecks
null과 undefined가 모든 타입에서 허용되는지 확인하는 설정이다.
`const x: number = null;`
- false일 때
  - 정상
- true일 때
  - null형식은 number형식에 할당할 수 없습니다.

null대신 undefined를 써도 같은 오류가 난다. 만약 null을 허용하려고 한다면 의도를 명시적으로 드러냄으로써 오류를 고칠 수 있다.<br>
`const x: number | null = null;`
만약 null을 허용하지 않으려면, 이 값이 어디서부터 왔는지 찾아야 하고, null을 체크하는 코드나 단언문을 추가해야 한다.

``` ts
const el = document.getElementById('status');
// el.textContent = 'Ready' => null인 것 같습니다.
if(el) el.textContent = 'Ready'; // null 제외
el!.textContent = 'Ready' // el이 null이 아님을 단언한다.
```

`strictNullChecks`는 nullrhk undefined 관련된 오류를 잡아 내는 데 많은 도움이 되지만, 코드 작성을 어렵게 한다. `strictNullChecks`를 설정하려면 `noImplicitAny`를 먼저 설정해야 한다.<br>
`strictNullChecks` 설정 없이 개발하기로 선택했다면 `undefined는 객체가 아닙니다.`라는 끔찍한 런타임 오류를 주의해야 한다. 프로젝트가 거대해질수록 설절 반경은 어려워질 것이므로, 가능한 한 초반에 설정하는 게 좋다.<br>
만약 언어에 의미적으로 영향을 미치는 설정들을(noImplicitThis, strictFunctionTypes 등) 체크하고 싶다면 `strict`설정을 하면 된다. 대부분의 오류를 잡아내줄 것이다.


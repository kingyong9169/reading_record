# 아이템 34 : 부정확한 타입보다는 미완성 타입을 사용하기

## 타입 안정성에서 불쾌한 골짜기는 피해야 한다. 타입이 없는 것보다 잘못된 게 더 나쁘다.
일반적으로 타입이 구체적일수록 버그를 더 많이 잡고 TS가 제공하는 도구를 활용할 수 있게 된다. but 타입 선언의 정밀도를 높이는 일에는 주의를 기울여야 한다. 실수가 발생하기 쉽고 잘못된 타입은 차라리 타입이 없는 것보다 못할 수 있기 때문이다.
``` ts
interface Point {
  type: 'Point'.
  coordinate: number[];
}
interface LineString {
  type: 'LineString';
  coordinate: number[][];
}
interface Polygon {
  type: 'Polygon';
  coordinate: number[][][];
}
type Geometry = Point | LineString | Polygon; // 다른 것들도 추가될 수 있다.
```

큰 문제는 없지만 좌표에 쓰이는 number[]가 약간 추상적이다'. 여기서 number[]는 경도와 위도를 나타내므로 튜플 타입으로 선언하는 게 낫다.

``` ts
type GeoPosition = [number, number];
interface Point {
  type: 'Point'.
  coordinate: GeoPosition;
}
```

## 정확하게 타입을 모델링할 수 없다면, 부정확하게 모델링하지 말아야 한다. 또한 any와 unknown을 구별해서 사용해야 한다.
타입을 더 구체적으로 개선했기 때문에 더 나은 코드가 된 것 같겠지만 아니다. 코드에는 위도와 경도만을 명시했지만, `GeoJSON`의 위치 정보에는 세 번째 요소인 고도가 있을 수 있고 또 다른 정보가 있을 수도 있다. 결과적으로 타입 선언을 세밀하게 만들고자 했지만 시도가 너무 과했고 오히려 타입이 부정확홰졌다. 
현재의 타입 선언을 그대로 사용하려면 유저들은 타입 단언문을 도입하거나 `as any`를 추가해서 타입 체커를 완전히 무시해야 한다.<br>

JSON으로 정의된 Lisp와 비슷환 언어의 타입 선언을 작성한다고 생각해 보겠습니다.
``` ts
12
"red"
["+", 1, 2]
["/", 20, 2]
["case", ["/", 20, 2], "red", "blue"]
["rgb", 255, 0, 127]
```
맵박스 라이브러리는 이런 시스템을 사용하여 수많은 기기에서 지도 기능의 형태를 결정한다. 다음은 이런 동작을 모델링해 볼 수 있는 입력값의 전체 종류이다.

1. 모두 허용
2. 문자열, 숫자, 배열 허용
3. 문자열, 숫자, 알려진 함수 이름으로 시작하는 배열 허용
4. 각 함수가 받는 매개변수의 개수가 정확한지 확인
5. 각 함수가 받는 매개변수의 타입이 정확한지 확인

처음 두 개 옵션은 간단하다.
``` ts
type Expression1 = any;
type Expression2 = numaber | string | any[];
```

표현식의 유효성을 체크하는 테스트 세트를 도입해 보겠다. 타입을 구체적으로 만들수록 정밀도가 손상되는 것을 방지하는 데 도움이 된다.

``` ts
const tests: Expression2[] = [
  12
  "red",
  true, // 타입에 맞지 않음
  ["+", 1, 2],
  ["/", 20, 2],
  ["*", 20, 2], // *는 함수가 아니므로 오류가 발생해야 한다.
  ["case", ["/", 20, 2], "red", "blue", "green"], // 값이 너무 많다.
  ["rgb", 255, 0, 127],
  ["rgb", 255, 0, 127, 0], // 값이 너무 많다.
]
```

정밀도를 높이기 위해 튜플의 첫 번째 요소에 문자열 리터럴 타입의 유니온을 사용해 보겠습니다.
``` ts
type FnName = '+' | '-' | '*' | '/' | '>' | '<' | 'case' | 'rgb';
type CallExpression = [FnName, ...any[]];
type Expression3 = number | string | CallExpression;

const tests: Expression3[] = [
  12
  "red",
  true, // 타입에 맞지 않음
  ["+", 1, 2],
  ["/", 20, 2],
  ["*", 20, 2],
  ["case", ["/", 20, 2], "red", "blue", "green"],
  ["rgb", 255, 0, 127],
]
```

각 함수의 매개변수 개수가 정확한지 확인하기 위해 모든 함수 호출을 확인할 수도 있지만 재귀적으로 동작하기 때문에 좋은 방법은 아니다. TS 3.6에서는 함수의 매개변수 개수를 알아내기 위해 최소한 하나의 인터페이스를 추가해야 한다. 여러 인터페이스를 호출 표현식으로 한 번에 묶을 수는 없기 때문에, 각 인터페이스를 나열해서 호출 표현식을 작성한다. 고정 길이 배열은 튜플 타입으로 가장 간단히 표현할 수 있기 때문에, 어색해보일 수는 있지만 다음 코드처럼 구현할 수 있다.

``` ts
type Expression4 = number | string | CallExpression;

type CallExpression = MathCall | CaseCall | RGBCall;

interface MathCall {
  0: '+' | '-' | '/' | '*' | '>' | '<';
  1: Expression4;
  2: Expression4;
  length: 3;
}

interface CaseCall {
  0: 'case';
  1: Expression4;
  2: Expression4;
  3: Expression4;
  length: 4 | 6 | 8 | 10 | 12 | 14 | 16; // 등등
}

interface RGBCall {
  0: 'rgb';
  1: Expression4;
  2: Expression4;
  3: Expression4;
  length: 4;
}

const tests: Expression4[] = [
  12
  "red",
  true, // 타입에 맞지 않음
  ["+", 1, 2],
  ["/", 20, 2],
  ["*", 20, 2],
  ["case", ["/", 20, 2], "red", "blue", "green"], // 갯수가 맞지 않아 생기는 오류, ["case", [...], ...]형식은 string 형식에 할당할 수 없다.
  ["rgb", 255, 0, 127],
  ["rgb", 255, 0, 127, 73], // 갯수가 맞지 않아 생기는 오류 // .. 형식은 string 형식에 할당할 수 없다.
]
```

## 타입 정보를 구체적으로 만들수록 오류 메시지와 자동 완성 기능에 주의를 기울여야 한다. 정확도뿐만 아니라 개발 경험과도 관련된다.
위 코드에서는 TS 인터페이스를 사용해서 `짝수 길이의 배열`같은 것을 표현할 수 잇다. but 오류가 나면 엉뚱한 메시지를 출력한다.

타입 정보가 더 정밀해졌지만 결과적으로 이전 버전보다 개선되었다고 보기는 어렵다. 잘못 사용한 코드에서 오류가 발생하기는 하지만 오류 메시지는 더 난해해졌다. 언어 서비스는 타입 체크 못지않게 TS 경험에서 중요한 부분이므로, 타입 선언으로 인한 오류 메시지를 살펴보고 타입 선언이 동작해야 하는 곳에는 자동 완성을 적용하는 것이 좋다. 새 타입 선언은 더 구체적이지만 자동 완성을 방해하므로 TS 개발 경험을 해치게 된다.

타입 선언의 복잡성으로 인해 버그가 발생할 가능성도 높아졌다. 예를 들어, Expression4는 모든 수학 연산자에 두 개의 매개변수가 필요하지만, 맵박스 표현식에서는 +와 *가 더 많은 매개변수를 받을 수 있다. 또한 입력을 음수로 바꿔 주는 -는 한 개의 매개변수만 필요하다.
``` ts
const okExpressions: Expression4[] = [
  ['-', 12], // number 형식은 string 형식에 할당할 수 없다.
  ['+', 1, 2, 3], // number 형식은 string 형식에 할당할 수 없다.
  ['*', 2, 3, 4], // number 형식은 string 형식에 할당할 수 없다.
]
```
코드를 더 정밀하게 만들려던 시도가 너무 과했고 그로 인해 코드가 오히려 더 부정확해졌다. 이렇게 부정확함을 바로잡는 방법을 쓰는 대신, 테스트 셋을 추가하여 놓친 부분이 없는지 확인해도 된다. 일반적으로 복잡한 코드는 더 많은 테스트가 필요하고 타입의 관점에서도 마찬가지이다.

타입을 정제할 때, 불쾌한 골짜기 은유를 생각해보면 도움이 될 수 있다. 일반적으로 any 같은 매우 추상적인 타입은 정제하는 것이 좋다. but 타입이 구체적으로 정제된다고 해서 정확도가 무조건 올라가지는 않는다. 타입에 의존하기 시작하면 부정확함으로 인해 발생하는 문제는 더 커질 것이다.
> 불쾌한 골짜기:<br>어설프게 인간과 비슷한 로봇에서 느끼는 불쾌함을 뜻한다. 저자의 의도는 타입 선언에서 어설프게 완벽을 추구하려다가 오히려 역효과가 발생하는 것을 주의하자는 것이다.

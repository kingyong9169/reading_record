# 아이템 16: number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기

JS는 이상하게 동작하기로 유명한 언어입니다. 그중 악명 높은 것은 암시적 타입 강제와 관련된 부분입니다.
``` ts
> "0" == 0
true
```
다행히도 암시적 타입 강제와 관련된 문제는 대부분 ===와 !==를 사용해서 해결이 가능합니다.<br>
JS객체 모델에도 이상한 부분들이 있으며, 이 중 일부는 TS 타입 시스템으로 모델링되기 때문에 JS 객체 모델을 이해하는 것이 중요합니다. 

## 배열은 객체이므로 키는 숫자가 아니라 문자열. 인덱스 시그니처로 사용된 number 타입은 버그를 잡기 위한 순수 TS 코드.
JS에서 객체란 키/값 쌍의 모음입니다. 키는 보통 문자열입니다.(ES6이후론 심벌일 수 있습니다.) 그리고 값은 어떤 것이든 될 수 있습니다. 파이썬, 자바에서 볼 수 있는 `해시 가능` 객체라는 표현이 JS에는 없습니다. 만약 더 복잡한 객체를 키로 사용하려고 하면, `toString`메소드가 호출되어 객체가 문자열로 변환됩니다.
``` ts
> x = {}
{}
> x[[1, 2, 3]] = 2
2
> x
{ '1,2,3': 1 }
```
특히, 숫자는 키로 사용할 수 없습니다. 만약 속성 이름으로 숫자를 사용하려고 하면, JS 런타임은 문자열로 변환할 겁니다.
``` ts
> { 1: 2, 3: 4 }
{ '1': 2, '3': 4 }
```
이번엔 배열을 알아보겠습니다. 배열은 분명히 객체입니다.
``` ts
> typeof []
'object'
```
그러니 숫자 인덱스를 사용하는 것이 당연합니다.
``` ts
> x = [1, 2, 3]
[1, 2, 3]
> x[0]
1
```
이상하게 보일지 모르지만, 앞의 인덱스들은 문자열로 변환되어 사용됩니다. 문자열 키를 사용해도 역시 배열의 요소에 접근할 수 있습니다.
``` ts
> x['1']
2
```

`Object.keys`를 이용해 배열의 키를 나열해 보면, 키가 문자열로 출력됩니다.
``` ts
> Object.keys(x)
[ '0', '1', '2' ]
```
**TS는 이러한 혼란을 바로잡기 위해 숫자 키를 허용하고, 문자열 키와 다른 것으로 인식합니다.**
``` ts
interface Array<T> {
  // ...
  [n: number]: T;
}
```
런타임에는 ECMAScript 표준이 서술하는 것처럼 문자열 키로 인식하므로 이 코드는 완전히 가상이라고 할 수 있지만, 타입 체크 시점에 오류를 잡을 수 있어 유용합니다.

``` ts
const xs = [1, 2, 3];
const x0 = xs[0];
const x1 = xs['1']; // 인덱스가 number형식이어야 함.

function get<T>(array: T[], k: string): T {
  return array[k]; // k가 number형식이어야 함.
}
```

다시 한 번 말하지만, 이 코드는 실제로 동작하지 않습니다. 그리고 TS 타입 시스템의 다른 것들과 마찬가지로, **타입 정보는 런타임에 제거됩니다.** 한편 `Object.keys`같은 구문은 여전히 문자열로 반환됩니다.
``` ts
const keys = Object.keys(xs); // string[]
for(const key in xs) {
  key; // string
  const x = xs[key] // number
}
```
string이 number에 할당될 수 없기 때문에, 예제의 마지막 줄이 동작하는 것이 이상하게 보일 겁니다. 배열을 순회하는 코드 스타일에 대한 실용적인 허용이라고 생각하는 것이 좋습니다. JS에서는 흔한 일이지만, 이 예제가 배열을 순회하기에 좋은 방법은 아닙니다. 인덱스에 신경 쓰지 않는다면, for-of를 사용하는 게 더 좋습니다.

만약 인덱스의 타입이 중요하다면, number타입을 제공해 줄 `Array.prototype.forEach`를 사용하면 됩니다.
``` ts
xs.forEach((x, i) => {
  i; // number
  x; // number
})
```

**타입이 불확실하다면, for-in루프는 for-of 또는 C스타일 for루프에 비해 몇 배나 느립니다.**

## 인덱스 시그니처에 number를 사용하기보다 Array, 튜플, ArrayLike타입을 사용하는 것이 좋다.
인덱스 시그니처가 number로 표현되어 있다면 입력한 값이 number여야 한다는 것을 의미하지만, 실제 런타임에 사용되는 키는 string타입.<br>
일반적으로 string 대신 number를 타입의 인덱스 시그니처로 사용할 이유는 많지 않습니다. 만약 숫자를 사용하여 인덱스할 항목을 지정한다면 Array 또는 튜플 타입을 대신 사용하게 될 겁니다. number를 인덱스 타입으로 사용하면 숫자 속성이 어떤 특별한 의미를 지닌다는 오해를 불러 일으킬 수 있습니다.

어떤 길이를 가지는 배열과 비슷한 형태의 튜플을 사용하고 싶다면 TS에 있는 `ArrayLike`타입을 사용합니다.
``` ts
function checkedAccess<T>(xs: ArrayLike<T>, i: number): T {
  if(i < xs.length) return xs[i];
  throw new Error(`배열의 끝을 지나서 ${i}를 접근하려고 했습니다.`)
}
```

이 예제는 길이와 숫자 인덱스 시그니처만 있습니다. 이런 경우가 실제로는 드물기는 하지만 필요하다면 ArrayLike를 사용해야 합니다. 그러나 ArrayLike를 사용하더라도 키는 여전히 문자열이라는 점을 잊지 말아야 합니다.

``` ts
const tupleLike: ArrayLike<string> = {
  '0': 'A',
  '1': 'B',
  length: 2,
}
```
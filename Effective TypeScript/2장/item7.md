# 아이템 7: 타입이 값들의 집합이라고 생각하기

## 타입을 값의 집합으로 생각하면 이해하기 편하다. 이 집합은 유한(boolean, 리터럴 타입)하거나 무한(number, string)하다.
런타임에 모든 변수는 JS 세상의 값으로부터 정해지는 각자의 고유한 값을 가진다. 그러나 코드가 실행되기 전, 즉 TS가 오류가 체크하는 순간에는 타입을 가지고 있다. `할당 가능한 값들의 집합`이 타입이라고 생각하면 된다. 이 집합은 타입의 `범위`라고 부르기도 한다.<br>
가장 작은 집합은 아무 값도 포함하지 않는 공집합이며, TS에서는 never타입이다. never타입으로 선언된 변수의 범위는 공집합이기 때문에 아무런 값도 할당할 수 없다.<br>
그 다음으로 작은 집합은 한 가지 값만 포함하는 타입이다. 이들은 TS에서 유닛타입이라고도 불리는 리터럴 타입이다.
``` ts
type A = 'A';
type B = 'B';
type Twelve = 12;
```

두 개 혹은 세 개로 묶으려면 유니온 타입을 사용한다.
``` ts
type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
```
유니온 타입은 값 집합들의 합집합을 일컫는다.

다양한 TS 오류에서 `할당 가능한`이라는 문구를 볼 수 있다. 이 문구는 집합의 관점에서 `~의 원소(값과 타입의 관계)` 또는 `~의 부분 집합(두 타입의 관계)`를 의미한다.
``` ts
const a: AB = 'A'; // 정상
const c: AB = 'C'; // '"C"' 형식은 'AB'형식에 할당할 수 없습니다.
```

C는 유닛 타입이다. 범위는 단일 값 "C"로 구성되며 AB의 부분 집합이 아니므로 오류다. 집합의 관점에서 `타입 체커의 주요 역할`은 `하나의 집합이 다른 집합의 부분 집합인지 검사하는 것`이라고 볼 수 있다.

또는 다음처럼 원소를 서술하는 방법도 있다.
``` ts
interface Identified {
    id: string;
}
```
인터페이스가 타입 범위 내의 값들에 대한 설명이라고 생각해 본다. 어떤 객체가 string으로 할당 가능한 id속성을 가지고 있다면 그 객체는 Identified이다.

## 한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있다.
`구조적 타이핑 규칙들은 어떠한 값이 다른 속성도 가질 수 있음`을 의미한다. 심지어 함수 호출의 매개변수에서도 다른 속성을 가질 수 있다. 이러한 사실은 특정 상황에서만 추가 속성을 허용하지 않는 잉여 속성 체크(express property checking)만 생각하다 보면 간과하기 쉽다.

## 객체 타입에서는 A & B인 값이 A와 B의 속성을 모두 가짐을 의미한다.
타입 연산은 집합의 범위에 적용된다. A와 B의 인터섹션은 A의 범위와 B의 범위의 인터섹션이다.
``` ts
interface Person {
  name: string;
}
interface Lifespan {
  birth: Date;
  death?: Date;
}
type PersonSpan = Person & Lifespan;
```

& 연산자는 두 타입의 인터섹션(교집합)을 계산한다. 언뜻 보면 두 인터페이스는 공통으로 가지는 속성이 없기 때문에 공집합(never)으로 예상하기 쉽다. 그러나 `타입 연산자는 인터페이스의 속성이 아닌, 값의 집합(타입의 범위)에 적용`된다. 그리고 추가적인 속성을 가지는 값도 여전히 그 타입에 속한다. 그래서 두 인터페이스 모두 가지는 값은 인터섹션 타입에 속하게 된다.

``` ts
const ps: PersonSpan = {
  name: 'Alan Turing',
  birth: new Date('1912/06/23'),
  death: new Date('1954/06/07'),
}
```

당연히 앞의 세 가지보다 더 많은 속성을 가지는 값도 PersonSpan타입에 속한다. 인터섹션 타입의 값은 각 타입 내의 속성을 모두 포함하는 것이 일반적인 규칙이다. 규칙이 속성에 대한 인터섹션에 관해서는 맞지만, 두 인터페이스의 유니온에서는 그렇지 않다.
``` ts
type K = keyof (Person | Lifespan); // 타입이 never
```
앞의 유니온 타입에 속하는 값은 어떠한 키도 없기 때문에, 유니온에 대한 keyof는 공집합(never)이어야만 한다. 조금 더 명확히 써 보자면 다음과 같다.
``` ts
keyof (A&B) = (keyof A) | (keyof B)
keyof (A|B) = (keyof A) & (keyof B)
```
이 등식은 TS의 타입 시스템을 이해하는 데 큰 도움을 될 것이다.

## A는 B를 상속, A는 B에 할당 가능, A는 B의 서브타입, A는 B의 부분 집합
TS타입은 엄격한 상속 관계가 아니라 겹쳐지는 집합(벤 다이어그램)으로 표현된다. 두 타입은 서로 서브타입이 아니면서도 겹쳐질 수 있다.

조금 더 일반적으로 타입을 선언하는 방법은 extends 키워드를 쓰는 것이다.
``` ts
interface person {
  name: string;
}
interface PersonSpan extends Person {
  birth: Date;
  death?: Date;
}
```
타입이 집합이라는 관점에서 extends의 의미는 `~에 할당 가능한`과 비슷하게 `~의 부분 집합`이라는 의미로 받아들일 수 있다. PersonSpan 타입의 모든 값은 name, birth를 가져야 제대로 된 부분 집합이 된다.<br>
> **_서브타입_**<br>
어떤 집합이 다른 집합의 부분 집합.

1차원, 2차원, 3차원 벡터의 관점에서 생각해 보면 다음과 같은 코드를 작성할 수 있다.
``` ts
interface Vertor1D { x: number; }
interface Vertor2D extends Vertor1D { y: number; }
interface Vertor3D extends Vertor2D { z: number; }
```

Vector3D는 Vector2D의 서브타입이고 Vector2D는 Vector1D의 서브타입이다. 보통 이 관계는 상속 관계로 그려지지만, 집합의 관점에서는 벤 다이어그램으로 그리는 게 더욱 적절하다.
``` ts
function getKey<K extends string>(val: any, key: K) {
  // ...
}
```
string을 상속한다는 의미를 객체 상속의 관점으로 생각한다면 이해하기가 어렵다. 반면 string을 상속한다는 의미를 집합의 관점에서 생각해보면 쉽게 이해할 수 있다. string의 부분 집합 범위를 가지는 어떠한 타입이 된다. 이 타입은 string리터럴 타입, string리터럴 타입의 유니온, string자신을 포함한다.

타입들이 엄격한 상속 관계가 아닐 때는 집합 스타일이 더욱 바람직하다. 예를 들어, `string|number`와 `string|Date` 사이의 인터섹션은 공집합이 아니며(string이다.) 서로의 부분 집합도 아니다.<br>
타입이 집합이라는 관점은 배열과 튜플의 관계 역시 명확하게 만든다.
``` ts
const list = [1, 2]; // number[]
const tuple: [number, number] = list; // number[] 타입은 [number, number] 타입의 0, 1 속성에 없습니다.
```

이 코드에서 숫자 배열을 숫자들의 쌍이라고 할 수는 없다. 빈 리스트와 [1]이 그 반례이다. `number[]`는 `[number, number]`의 부분 집합이 아니기 때문에 할당할 수 없다.(반대는 동작한다.)

트리플(세 숫자를 가지는 타입)은 구조적 타이핑의 관점으로 생각하면 쌍으로 할당 가능할 것으로 생각된다. 그렇다면 쌍은 0, 1번 키를 가지므로, 2번 같은 다른 키를 가질 수 있을지 확인해 본다.
``` ts
const triple: [number, number, number] = [1, 2, 3];
const double: [number, number] = triple;
// [number, number, number] 형식은 [number, number] 형식에 할당할 수 없습니다.
// length 속성의 형식이 호환되지 않습니다.
// 3 형식은 2 형식에 할당할 수 없습니다.
```
오류가 발생했는데 그 이유가 매우 흥미롭다. TS는 숫자의 쌍을 {0: number, 1: number} 로 모델링하지 않고 {0: number, 1: number, length: 2}로 모델링했다. 그래서 length의 값이 맞지 않기 때문에 할당문에 오류가 발생했다. 쌍에서 길이를 체크하는 것은 합리적이다.<br>
타입이 값의 집합이라는 건, 동일한 값의 집합을 가지는 두 타입은 같다는 의미가 된다. 두 타입이 의미적으로 다르고 우연히 같은 범위를 가진다고 하더라도, 같은 타입을 두 번 정의할 이유는 없다.

한편 TS 타입이 되지 못하는 값의 집합들이 있다는 것을 기억해야 한다. 정수에 대한 타입, 또는 x 와 y 속성 외에 다른 속성이 없는 객체는 TS 타입에 존재하지 않는다. 가끔 `Exclude`를 사용해서 일부 타입을 제외할 수 이는 있지만, 그 결과가 적절한 TS타입일 때만 유효하다.

``` ts
type T = Exclude<string|Date, string|number>; // 타입은 Date
type NonZeroNums = Exclude<number, 0>; // 타입은 여전히 number
```

## 타입스크립트 용어 및 집합 용어
- `never` : 공집합
- `리터럴 타입` : 원소가 1개인 집합
- `값이 T에 할당 가능` : 값이 T의 원소
- `T1이 T2에 할당 가능` : T1이 T2의 부분 집합
- `T1이 T2를 상속` : T1이 T2의 부분 집합
- `T1 | T2(유니온)` : T1과 T2의 합집합
- `T1 & T2(인터섹션)` : T1과 T2의 교집합
- `unknown` : 전체(universal)집합

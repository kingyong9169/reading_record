# 3장 타입 추론
- C, C++, 자바에서는 타입을 직접 명시함.
- 학술계로 분류되는 ML, 하스켈 같은 언어는 오래전부터 정교한 타입 추론 시스템을 가지고 있었다.
- 학술계 언어의 발전에 대응하여 10년전부터 기존 산업계의 언어에도 타입 추론 기능이 추가됨. C++은 auto를, 자바는 var를 추가함.

ts는 타입 추론을 적극적으로 수행함. 타입 추론은 수동으로 명시해야 하는 타입 구문의 수를 엄청나게 줄여 주기 때문에, 코드의 전체적인 안정성이 향상됨.

3장에서는 타입 추론에서 발생할 수 있는 몇 가지 문제와 그 해법을 안내함. ts가 어떻게 타입을 추론하는지, 언제 타입 선언을 작성해야 하는지, 타입 추론이 가능하더라도 명시적으로 타입 선언을 작성하는 것이 필요한 상황은 언제인지 이해해보자.

# 아이템 19: 추론 가능한 타입을 사용해 장황한 코드 방지하기
ts를 처음 접하는 사람들은 가장 먼저 하는 일은 타입 구문을 넣는 일이다. but ts의 많은 타입 구문은 사실 불필요하다.

```ts
let x = 12;
```
처럼만 해도 충분하다. 편집기에서 마우스로 올려 보면, number로 추론되어 있음을 알 수 있다. 즉, **타입 추론이 된다면 명시적 타입 구문은 필요하지 않다.** 오히려 방해가 될 수 있다.

```ts
const axis1: string = 'x';
const axis2 = 'y';
```
axis2 변수를 string으로 예상하기 쉽지만 ts가 추론한 'y'가 더 정확한 타입이다.

타입이 추론되면 리팩터링 역시 용이해진다.
```ts
interface Product {
  id: number;
  name: string;
  price: number;
}

function logProduct(product: Product) {
  const id: number = product.id;
  const name: string = product.name;
  const price: number = product.price;
  console.log(id, name, price);
}
```

여기서 Product의 id가 string으로 바뀌면 logProduct 내부도 수정해줘야 한다. 타입 구문을 안썼다면 수정 없이 타입 체커를 통과했을 것이다. **비구조화 할당문을 사용해 구현하는 게 낫다.**

```ts
function logProduct(product: Product) {
  const { id, name, price } = product;
  console.log(id, name, price);
}
```

비구조화 할당문은 모든 지역 변수의 타입이 추론되도록 한다. 여기에 추가로 명시적 타입 구문을 넣는다면 불필요한 타입 선언으로 인해 코드가 번잡해 진다.

정보가 부족해서 ts가 스스로 타입을 판단하기 어려운 상황도 일부 있다. 그럴 때는 명시적 타입 구문이 필요하다. logProduct에서 매개변수 타입을 명시한 경우가 그 예이다.

어떤 언어들은 매개변수의 최종 사용처까지 참고하여 타입을 추론하지만, **ts는 최종 사용처까지 고려하지 않는다. ts에서 변수의 타입은 일반적으로 처음 등장할 때 결정된다.**

이상적인 ts코드는 함수/메서드 시그니처에 타입 구문을 포함하지만, 함수 내에서 생성된 지역 변수에는 타입 구문을 넣지 않는다. **타입 구문을 생략하여 방해되는 것들을 최소화하고 코드를 읽는 사람이 구현 로직에 집중할 수 있게 하는 것이 좋다.**

기본값이 있는 경우에 함수 매개변수에 타입 구문을 생략하곤 한다.

```ts
function parseNumber(str: string, base = 10) {
  ...
}
```
여기서 base는 number로 추론된다.

보통 타입 정보가 있는 라이브러리에서, 콜백 함수의 매개변수 타입은 자동으로 추론된다.

```ts
app.get('/health', (req, res) => {
  res.send('ok');
});
```

타입이 추론될 수 있음에도 여전히 타입을 명시하고 싶은 몇 가지 상황이 있다. 그 중 하나는 객체 리터럴을 정의할 때이다.

```ts
const elmo: Product = {
  id: '2323',
  name: 'Tickle Me Elmo',
  price: 20
}
```

이런 정의에 타입을 명시하면, **잉여 속성 체크**가 동작한다. **잉여 속성 체크는 특히 선택적 속성이 있는 타입의 오타 같은 오류를 잡는 데 효과적이다.** 그리고 변수가 사용되는 순간이 아닌 할당하는 시점에 오류가 표시되도록 해 준다.

만약 타입 구문을 제거한다면 잉여 속성 체크가 동작하지 않고, 객체를 선언한 곳이 아니라, 객체가 사용되는 곳에서 타입 오류가 발생한다. but **타입을 제대로 명시한다면, 실제로 실수가 발생한 부분에 오류를 표시해 준다.**

마찬가지로 함수의 반환에도 타입을 명시하여 오류를 방지할 수 있다. **타입 추론이 가능할지라도 구현상의 오류가 함수를 호출한 곳까지 영향을 미치지 않도록 하기 위해 타입 구문을 명시하는게 좋다.**

```ts
const cache: { [ticker: string]: number } = {};

function getQuote(ticker: string) {
  if(ticker in cache) {
    return cache[ticker];
  }
  return fetch(`https://quotes.example.com/?q=${ticker}`)
    .then(res => res.json())
    .then(quote => {
      cache[ticker] = quote;
      return quote;
    });
}
```
그런데 이 코드에는 오류가 있다. getQuote는 항상 Promise를 반환하므로 if 구문에는 cache[ticker]가 아니라 Promise.resolve(cache[ticker])가 반환되도록 해야 한다. 실행해보면 오류는 getQuote를 호출한 코드에서 발생한다.

이때 의도된 반환 타입(Promise<number>)를 명시한다면, 정확한 오류가 표시된다.

**반환 타입을 명시하면, 구현상의 오류가 사용자 코드의 오류로 표시되지 않는다.** 오류의 위치를 제대로 표시해 주는 이점 외에도, 반환 타입을 명시해야 하는 이유가 두 가지 더 있다.

1. 반환 타입을 명시하면 함수에 대해 더욱 명확하게 알 수 있다.
- 구현하기 전에 입력 및 출력 타입이 무엇인지 알아야 한다. 추후에 코드가 조금 변경되어도 그 함수의 시그니처는 쉽게 바뀌지 않는다.
- 미리 타입을 명시하는 방법은, TDD와도 비슷하다. 전체 타입 시그니처를 먼저 작성하면 구현에 맞추어 주먹구구식으로 시그니처가 작성되는 것을 방지하고 제대로 원하는 모양을 얻게 된다.
2. 명명된 타입을 사용하기 위해서이다.
- 입력 타입은 명시되었지만 출력 타입이 명시되지 않으면 개발자 입장에서 당혹스러울 수 있다.
```ts
interface Vecter2D {
  x: number;
  y: number;
}
```
에서 Vecter2D가 아닌 `{ x: number; y: number; }`로 나타나기 때문이다.
- 반환된 타입을 명시하면 직관적인 표현이 된다. 
- 반환 값을 별도의 타입으로 정의하면 타입에 대한 주석을 작성할 수 있어서, 더욱 자세한 설명이 가능해진다.

linter를 사용하고 있다면, `no-inferrable-types`을 사용해서 작성된 모든 타입 구문이 정말로 필요한지 확인할 수 있다.

## 요약
- ts가 타입을 추론할 수 있다면 타입 구문을 작성하지 않는 게 좋다.
- 이상적인 경우 함수/메서드의 시그니처에는 타입 구문이 있지만, 함수 내의 지역 변수에는 타입 구문이 없다.
- 추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 고려해야 한다. 내부 구현의 오류가 사용자 코드 위치에 나타나는 것을 방지한다.

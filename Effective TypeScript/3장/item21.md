# 타입 넓히기
런타임에 모든 변수는 유일한 값을 가진다. 그러나 ts가 작성한 코드를 체크하는 정적 분석 시점에, 변수는 **가능한** 값들의 집합인 타입을 가진다. 상수를 사용해서 변수를 초기화할 때 타입을 명시하지 않으면 타입 체커는 타입을 결정해야 한다. 즉, 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야 한다는 뜻이다. ts에서는 이러한 과정을 **넓히기(widening)**라고 부른다. 넓히기의 과정을 이해한다면 오류의 원인을 파악하고 타입 구문을 더 효과적으로 사용할 수 있다.

```ts
interface Vector3 { x: number; y: number; z: number; }
function getComponent(vector: Vector3, axis: 'x' | 'y' | 'z') {
  return vector[axis];
}

let x = 'x';
let vec = { x: 10, y: 20, z: 30 };
getComponent(vec, x); // string 형식의 인수는 'x' | 'y' | 'z' 형식의 매개변수에 할당될 수 없습니다.
```

실행은 되지만 편집기에서 오류가 표시된다.

getComponent 함수는 두 번째 매개변수에 `'x' | 'y' | 'z'` 타입을 기대했지만, x의 타입은 할당 시점에 넓히기가 동작해서 string으로 추론되었다.

타입 넓히기가 진행될 때, 주어진 값으로 추론 가능한 타입이 여러 개이기 때문에 과정이 상당히 모호하다.

```ts
const mixed = ['x', 1];
```

다음은 추론될 수 있는 후보들이다.
1. ('x' | 1)[]
2. ['x', 1]
3. [string, number]
4. readonly [string, number]
5. (string | number)[]
6. readonly (string | number)[]
7. [any, any]
8. any[]

정보가 충분하지 않다면 mixed가 어떤 타입으로 추론되어야 하는지 알 수 없다. 그러므로 ts는 작성자의 의도를 추측한다.(이 경우에는 5번째로 추측한다.) but ts가 아무리 영리하더라도 사람의 마음을 읽을 수는 없다.

```ts
let x = 'x';
x = 'a';
x = 'four';

let x = 'x';
x = /x|y|z/;
x = ['x', 'y', 'z'];
```

ts는 x의 타입을 string으로 추론할 때, **명확성과 유연성 사이의 균형을 유지하려고 한다.** 일반적인 규칙은 변수가 선언된 후로는 타입이 바뀌지 않아야 하므로 string|RegExp, string|string[], any보다 string이 더 좋은 선택이다.

## ts는 넓히기의 과정을 제어할 수 있도록 몇 가지 방법을 제공한다.
### const
- 만약 let대신 const로 변수를 선언하면 더 좁은 타입이 된다.
```ts
const x = 'x';
let vec = { x: 10, y: 20, z: 30 };
getComponent(vec, x); 
```
- x는 재할당될 수 없으므로 ts는 의심의 여지 없이 더 좁은 타입인 'x'로 추론한다.

but const가 만능이 아니다. 객체, 배열의 경우 문제가 있다. 튜플 타입인지, 요소들은 어떤 타입으로 추론해야 할지 알 수 없다.

```js
const v = {
  x: 1,
};
v.x = 3;
v.x = '3';
v.y = 4;
v.name = 'Pythagoras';
```

v의 타입은 구체적인 정도에 따라 다양한 모습으로 추론될 수 있다. 가장 구체적인 경우는 `{ readonly x: 1 }`이다. 조금 추상적으로는 `{ x: number }`이다. 가장 추상적이라면 `{ [x: string]: number }` or `object`이다.

**객체의 경우 ts의 넓히기 알고리즘은 각 요소를 let으로 할당된 것처럼 다룬다.** 그래서 `{ x: number }`가 된다. 덕분에 v.x를 다른 숫자로 재할당 할 수 있지만 string으로 재할당할 수 없고 다른 속성을 추가하지도 못한다.

앞에서도 언급했듯이 **ts는 명확성과 유연성 사이의 균형을 유지하려고 한다.** 오류를 잡기 위해서는 충분히 구체적으로 타입을 추론해야 하지만, 잘못된 추론을 할 정도로 구체적으로 수행하지는 않는다. 예들 들어, 1을 적당히 number로 추론한다.

## 타입 추론의 강도를 직접 제어하려면 ts의 기본 동작을 재정의해야 한다.
1. 명시적 타입 구문 제공
```ts
const v: { x: 1|3|5 } = {
  x: 1,
} // { x: 1|3|5 }
```

2. 타입 체커에 추가적인 문맥 제공(예를 들어, 함수의 매개변수로 값을 전달)

3. const 단언문 사용
- const 단언문과 변수 선언에 쓰이는 let, const를 혼동해서는 안 된다.
- 온전히 타입 공간의 기법이다.

```ts
const v1 = {
  x: 1,
  y: 2,
}; // { x: number; y: number; }

const v2 = {
  x: 1 as const,
  y: 2,
}; // { x: 1; y: number; }

const v3 = {
  x: 1,
  y: 2,
} as const; // { readonly x: 1; readonly y: 2; }
```

값 뒤에 as const를 작성하면, ts는 최대한 좁은 타입으로 추론한다. v3에는 넓히기가 동작하지 않았다.

튜플에도 as const를 사용할 수 있다.
```ts
const a1 = [1, 2, 3]; // number[]
const a2 = [1, 2, 3] as const; // readonly [1, 2, 3]
```

**넓히기로 인해 오류가 발생한다고 생각되면, 명시적 타입 구문 또는 const 단언문을 사용하자.**

# 요약
- ts가 넓히기를 통해 상수의 타입을 추론하는 법을 이해해야 한다.
- 동작에 영향을 줄 수 있는 방법인 const, 타입 구문, 문맥, as const에 익숙해져야 한다.

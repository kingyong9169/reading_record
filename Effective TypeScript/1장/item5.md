# 아이템 5: any 타입 지양하기
TS의 타입 시스템은 점진적(gradual)이고 선택적(optional)이다.<br>
코드에 타입을 조금씩 추가할 수 있기 때문에 점진적이며, 언제든지 타입 체커를 해제할 수 있기 때문에 선택적이다. 이 기능들의 핵심은 any타입이다.

``` ts
let age: number;
age = '12' // '"12"' 형식은 number형식에 할당할 수 없다.
age = '12' as any: // OK
```
오류를 찾아냈지만 `as any`를 추가해서 해결할 수 있따. 일부 특별한 경우를 제외하고는 `any`를 사용하면 TS의 수많은 장점을 누릴 수 없게 된다. 부득이하게 `any`를 사용하더라도 그 위험성을 알고 있어야 한다.

### any 타입에는 타입 안전성이 없다.
앞선 예제에서는 `age`를 `number`타입으로 선언했다. 그러나 `as any`를 사용하여 `string` 타입을 할당할 수 있게 됐다. 타입 체커는 선언에 따라 `number`타입으로 판단할 것이고 혼돈은 걷잡을 수 없게 된다.
``` ts
age += 1; // 런타임에 정상, age는 "121"
```

## any는 함수 시그니처를 무시해 버린다.
함수를 작성할 때는 시그니처를 명시해야 한다. 호출하는 쪽은 약속된 타입의 입력을 제공하고, 함수는 약속된 타입의 출력을 반환한다. 그러나 `any`타입을 사용하면 이런 약속을 어길 수 있다.

> `시그니처`<br>
원서에는 시그니처 대신 contract로 표기. 직역하면 계약, 약속 정도이다. but 이 문맥에서 계약이란 단어는 어색하고 시그니처가 더 이해하기 좋다.

``` ts
function calculateAge(birthDate: Date): number {
  // ...
}
let birthDate: any = '1990-01-19';
calculateAge(birthDate); // 정상
```

`birthDate` 매개변수는 `string`이 아닌 `Date` 타입이어야 한다. `any`타입을 사용하면 `calculateAge`의 시그니처를 무시하게 된다. JS에서는 종종 암시적으로 타입이 변환되기 때문에 이런 경우 특히 문제가 될 수 있다. `string`타입은 `number` 타입이 필요한 곳에서 오류 없이 실행될 때가 있고, 그럴 경우 다른 곳에서 문제를 일으키게 된다.

## any 타입에는 언어 서비스가 적용되지 않는다.(개발 경험을 나쁘게 한다.)
어떤 심벌에 타입이 있다면 TS 언어 서비스는 자동완성 기능과 적적한 도움말을 제공한다.<br>
but `any`타입인 심벌을 사용하면 아무런 도움을 받지 못한다.<br>
이름 변경 기능은 또 다른 언어 서비스이다. TS의 모토는 '확장 가능한 JS'이다. '확장'의 중요한 부분은 바로 TS 경험의 핵심 요소인 언어 서비스이다. 언어 서비스를 제대로 누려야 생산성이 향상된다.

## any 타입은 코드 리팩터링 때 버그를 감춘다.
`any`가 아니라 구체적인 타입을 사용하면, 타입 체커가 오류를 발견한다.

## any는 타입 설계를 감춰버린다.
애플리케이션 상태 같은 객체를 정의하려면 꽤 복잡하다. 상태 객체 안에 있는 수많은 속성의 타입을 일일이 작성해야 하는데, any타입을 사용하면 간단히 끝내버릴 수 있다.<br>
물론 이때도 `any`를 사용하면 안된다. 이유는 앞에서 설명해 왔다. 객체를 정의할 때 특히 문제가 되는데, 상태 객체의 설계를 감춰버리기 때문이다. 깔끔하고 정확하고 명료한 코드 작성을 위해 제대로 된 타입 설계는 필수이다. `any`타입을 사용하명 타입 설계가 불분명해진다. 설계가 잘 되었는지, 설계가 어떻게 되어 있는지 전혀 알 수 없다. 만약 동료가 코드를 검토해야 한다면, 동료는 애플리케이션의 상태를 어떻게 변경했는지 코드부터 재구성해 봐야 할 것이다. 그러므로 설계가 명확히 보이도록 타입을 일일이 작성하는 것이 좋다.

## any는 타입시스템의 신뢰도를 떨어뜨린다.
사람은 항상 실수를 한다. 보통은 타입 체커가 실수를 잡아주고 코드의 신뢰도가 높아진다. 그러나 런타임에 타입 오류를 발견하게 된다면 타입 체커를 신뢰할 수 없을 것이다. `any`타입을 쓰지 않으면 런타임에 발견될 오류를 미리 잡을 수 있고 신뢰도를 높일 수 있다.<br>
TS는 개발자의 삶을 편하게 하는 데 목적이 있지만, 코드 내에 존재하는 수많은 `any`타입으로 인해 JS보다 일을 더 어렵게 만들기도 한다. 타입 오류를 고쳐야 하고 여전히 머릿속에 실제 타입을 기억해야 하기 때문이다. 타입이 실제 값과 일치한다면 타입 정보를 기억해 둘 필요가 없다. TS가 타입 정보를 기억해 주기 때문이다.<br>
어쩔 수 없이 `any`를 써야만 하는 상황도 있다. 이럴 때 고민해 볼 수 있는 좋은 방법과 좋지 못한 방법이 있다. `any`의 단점을 어떻게 보완해야 하는지는 5장에서 다룬다.

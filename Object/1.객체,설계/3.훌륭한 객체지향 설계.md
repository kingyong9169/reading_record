## 캡슐화와 응집도

> 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것

밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 **응집도(cohesion)**가 높다고 말한다.

자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있고 응집도를 높인다.

## 절차지향과 객체지향

> 수정 전: 과정의 절차를 구현

1. Theater의 enter메서드: 프로세스
2. Audience, TicketSeller, Bag, TicketOffice: 데이터

-> 절차적 프로그래밍, 프로세스와 데이터를 별도의 모듈에 위치시키는 방식

프로세스를 담당하는 것이 모든 데이터에 의존하고 있음.

모든 처리가 하나의 클래스 안에 위치하고 나머지 클래스는 단지 데이터의 역할만 수행하기 때문

절차적 프로그래밍의 세계에서는 관람객과 판매원이 수동적인 존재이다. 즉, 우리의 예상을 너무나도 쉽게 벗어나기 때문에 코드를 읽는 사람과 원활하게 의사소통하지 못한다.

크리티컬한 부분은 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어렵다는 것.

Audience와 TicketSeller의 내부 구현을 변경하려면 Theater의 enter 메서드를 함께 변경해야 한다. 변경은 버그를 부르고 버그에 대한 두려움은 코드를 변경하기 어렵게 만든다. 따라서 절차적 프로그래밍의 세상은 변경하기 어려운 코드를 양산하는 경향이 있다.

변경하기 쉬운 설계 => 한 번에 하나의 클래스만 변경할 수 있는 설계

절차적 프로그래밍은 프로세스가 필요한 모든 데이터에 의존해야 한다는 근본적인 문제점 때문에 변경에 취약함.

이를 해결하기 위해 자신의 데이터를 스스로 처리하도록 나눈다. 이처럼 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 **객체지향 프로그래밍**이라고 부른다.

훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것. 일반적으로 객체지향이 절차지향에 비해 변경에 좀 더 유연하다고 말하는 이유가 바로 이것.

객체지향 코드는 자신의 문제를 스스로 처리해야 한다는 우리의 예상을 만족시켜주기 때문에 이해하기 쉽고, 객체 내부의 변경이 객체 외부에 파급되지 않도록 제어할 수 있기 때문에 변경하기가 수월하다.

## 책임의 이동
두 방식 사이에 근본적인 차이는 **책임의 이동**이다. 책임 in OOP 을 기능으로 생각해도 무방하다.

<img width="600" alt="전" src="https://github.com/kingyong9169/reading_record/assets/62797441/23c84d16-a7b7-4a9f-981c-ba49212f987d">

- Theater가 전체적인 작업을 도맡아 처리함.

<img width="600" alt="후" src="https://github.com/kingyong9169/reading_record/assets/62797441/db009de3-7d76-4c6d-968e-2983e93adaec">

- 각 객체가 자신이 맡은 일을 스스로 처리함. 이것이 **책임의 이동**

이러한 관점에서 OOP를 데이터와 프로세스를 하나의 단위로 통합해 놓는 방식으로 표현하기도 함.
- 비록 구현 관점에서만 바라본 지극히 편협한 시각임.
- 동시에 입문자에게는 도움이 되는 실용적인 조언임.

- 객체지향 설계의 핵심은 적절한 객체에 적절한 책임을 할당하는 것.
- 객체는 다른 객체와의 협력이라는 문맥 안에서 특정한 역할을 수행하는 데 필요한 적절한 책임을 수행해야 함.
- 따라서 객체가 어떤 데이터를 가지냐?보다는 객체에 어떤 책임을 할당할 것이냐에 초점을 맞춰야 함.

설계를 어렵게 만드는 것은 **의존성**이다. 불필요한 의존성을 제거함으로써 객체 사이의 **결합도**를 낮추면 된다. 여기서 각 프로세스가 필요한 데이터는 내부로 감춰 **캡슐화**한다. 결과적으로 객체 내부로 캡슐화하는 것은 객체의 **자율성**을 높이고 **응집도** 높은 객체들의 공동체를 창조할 수 있게 한다. 즉, 최소한의 의존성만을 남기는 것이 훌륭한 객체지향 설계다.

# 객체, 설계

# 들어가기
대부분의 사람들: 이론이 먼저 정립된 후에 실무가 그 뒤를 따라 발전함.

글래스: 이론을 정립할 수 없는 초기에는 실무가 먼저 급속한 발전을 이룸. 실무가 어느 정도 발전하고 나면 실무의 실용성을 입증할 수 있는 이론이 서서히 그 모습을 갖춰가기 시작하고, 해당 분야가 성숙해지는 시점에 이르러서야 이론이 실무를 추월함.

-> 실무가 먼저임. 어떤 분야든 초기 단계에서는 무에서 이론을 정립하기보다 실무를 관찰한 결과를 바탕으로 이론 정립하는 것이 합당함. 소프트웨어가 아직 걸음마 단계이기에 실무가 더 중요하다는 견해.

실제로 훌륭한 설계에 대한 최초의 이론은 1970년대가 돼서야 비로소 세상에 모습을 드러냄. 실무에서 반복적을 적용되던 기법들을 이론화한 것들이 대부분. SW의 규모가 커지면 커질수록 SW 설계 분야에서 이론이 실무를 추월할 가능성은 희박함.

유지보수의 경우 그 격차가 더 심함. 이와 관련된 효과적인 이론이 발표된 적은 거의 없음.

## 결론
SW 설계나 유지보수에 중점을 두려면 이론X, 실무O

이 책은 훌륭한 객체지향 프로그램 설계 및 유지보수하는 데 필요한 원칙과 기법 설명을 위한 책. 추상적인 개념과 이론을 앞세우지 않을 것. 직접 코드를 작성하자.

# 티켓 판매 애플리케이션
> 이벤트에 당첨: 초대장을 티켓으로 교환하고 입장, 당첨X: 티켓을 구매해야 입장

<img width="600" alt="티켓 판매 애플리케이션 클래스 다이어그램" src="https://github.com/kingyong9169/reading_record/assets/62797441/3651ac1b-e57b-451a-8b30-82dd9ea45cc6">

```java
public class Invitation {
  private LocalDateTime when;
}

public class Ticket { 
  private Long fee;
  public Long getFee() {
    return fee;
  } 
}
```

```java
// 초대장이 있으면 입장, 없으면 티켓 구매 후 입장 -> 초대장, 티켓, 돈이 필요함.
// 현금과 초대장을 함께 보관 or 초대장 없이 현금만 보관하는 2가지 케이스이므로 생성자 추가
public class Bag {
  private Long amount;
  private Invitation invitation;
  private Ticket ticket;

  public Bag(long amount) {
    this(null, amount); 
  }
  public Bag(Invitation invitation, long amount) {  
    this.invitation = invitation;
    this.amount = amount;
  }
  public boolean hasInvitation() { 
    return invitation != null;
  }
  public boolean hasTicket() { 
    return ticket != null;
  }
  public void setTicket(Ticket ticket) { 
    this.ticket = ticket;
  }
  public void minusAmount(Long amount) { 
    this.amount -= amount;
  }
  public void plusAmount(Long amount) { 
    this.amount += amount;
  } 
}
```

```java
public class Audience { 
  private Bag bag;
  public Audience(Bag bag) { 
    this.bag = bag;
  }
  public Bag getBag() { 
    return bag;
  } 
}
```

관람객(Audience)가 소극장에 입장하기 위해 매표소에서 초대장을 티켓으로 교환 or 구매해야 한다. 따라서 매표소에는 관람객에게 판매할 티켓, 티켓의 판매 금액이 보관돼 있어야 함.

```java
public class TicketOffice {
  private Long amount; // 판매 금액
  private List<Ticket> tickets = new ArrayList<>(); // 티켓 목록
  public TicketOffice(Long amount, Ticket ... tickets) { 
    this.amount = amount; 
    this.tickets.addAll(Arrays.asList(tickets));
  }
  public Ticket getTicket() { 
    return tickets.remove(0);
  }
  public void minusAmount(Long amount) { 
    this.amount -= amount;
  }
  public void plusAmount(Long amount) { 
    this.amount += amount;
  }
}
```

```java
public class TicketSeller {
  // 매표소에서 초대장을 티켓으로 교환 or 티켓 판매 -> 자신이 일하는 매표소를 알고 있어야 함.
  private TicketOffice ticketOffice;
  public TicketSeller(TicketOffice ticketOffice) { 
    this.ticketOffice = ticketOffice;
  }
  public TicketOffice getTicketOffice() { 
    return ticketOffice;
  }
}
```

```java

public class Theater {
  private TicketSeller ticketSeller;
  public Theater(TicketSeller ticketSeller) { 
    this.ticketSeller = ticketSeller;
  }
  public void enter(Audience audience) {
    if (audience.getBag().hasInvitation()) { // 초대장이 있으면 티켓 교환
      Ticket ticket = ticketSeller.getTicketOffice().getTicket();
      audience.getBag().setTicket(ticket);
    } else { // 없으면 티켓 구매
      Ticket ticket = ticketSeller.getTicketOffice().getTicket(); 
      audience.getBag().minusAmount(ticket.getFee()); 
      ticketSeller.getTicketOffice().plusAmount(ticket.getFee()); 
      audience.getBag().setTicket(ticket);
    }
  }
}
```

하지만 몇 가지 문제점이 있음.

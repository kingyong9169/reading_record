# 복습
- 다형성은 지연 바인딩이라는 메커니즘을 통해 구현된다.
- 상속은 코드를 재사용할 수 있는 가장 널리 알려진 방법이지만 캡슐화의 측면에서 합성이 더 좋은 방법이다.
- 유연한 객체지향 프로그램을 위해서는 컴파일 시간 의존성과 실행 시간 의존성이 달라야 한다.

# 들어가기
객체지향 패러다임의 관점에서 핵심은 **역할, 책임, 협력**이다. 역할, 책임, 협력이 제자리를 찾지 못한 상태라면 응집도 높은 클래스와 중복 없는 상속 계층을 구현한다고 하더라고 애플리케이션이 침몰하는 것을 구원하지 못할 것이다. 클래스, 상속, 지연 바인딩이 중요하지 않은 것은 아니지만 다분히 구현 측면에 치우쳐 있기에 패러다임의 본질과는 거리가 멀다.

객체지향의 본질은 **협력하는 객체들의 공동체를 창조하는 것**이다. 객체지향 설계의 핵심은 **협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정에서 드러난다.**

클래스와 상속은 객체의 책임과 협력이 어느 정도 자리를 잡은 후에 사용할 수 있는 구현 메커니즘일 뿐이다. 애플리케이션의 기능을 구현하기 위해 어떤 협력이 필요하고 협력을 위해 어떤 역할과 책임이 필요한지를 구민하지 않은 채 너무 이른 시기에 구현에 초점을 맞추는 것은 변경하기 어렵고 유연하지 못한 코드를 낳는 원인이 된다.

# 1. 협력
## 영화 예매 시스템 돌아보기

<img width="600" alt="영화 예매 시스템 돌아보기" src="https://github.com/reactjs/ko.react.dev/assets/62797441/0e46ca61-8b74-4203-9040-be1f064ef78e" />

객체지향 원칙을 따르는 애플리케이션의 제어 흐름은 어떤 하나의 객체에 의해 통제되지 않고 다양한 객체들 사이에 균형 있게 분배되는 것이 일반적이다. 객체들은 요청의 흐름을 따라 자신에게 분배된 로직을 실행하면서 애플리케이션 전체 기능을 완성한다.

여기서 중요한 것은 다양한 객체들이 영화 예매라는 기능을 구현하기 위해 메시지를 주고받으면서 상호작용한다는 점이다. 이처럼 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 **협력**이라 한다. 객체가 협력에 참여하기 위해 수행하는 로직은 **책임**이라 한다. 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 **역할**을 구성한다.

## 협력
객체지향 시스템은 자율적인 객체들의 공동체다. 객체는 고립된 존재가 아니라 시스템의 기능이라는 더 큰 목표를 달성하기 위해 다른 객체와 협력하는 사회적인 존재다. 협력은 객체지향의 세계에서 기능을 구현할 수 있는 유일한 방법이다. 두 객체 사이의 협력은 하나의 객체가 다른 객체에게 도움을 요청할 때 시작된다. **메시지 전송**은 객체 사이의 협력을 위해 사용할 수 있는 **유일한 커뮤니케이션 수단**이다. 객체는 다른 객체의 상세한 내부 구현에 직접 접근할 수 없기 때문에 오직 메시지 전송을 통해서만 자신의 요청을 전달할 수 있다.

> 협력이란 어떤 객체가 다른 객체에게 무엇인가를 요청하는 것이다. 한 객체는 어떤 것이 필요할 때 다른 객체에게 전적으로 위임하거나 서로 협력한다. 즉,두 객체가 상호작용을 통해 더 큰책임을 수행하는 것이다.객체사이의 협력을 설계할 때는 객체를 서로 분리된 인스턴스가 아닌 협력하는 파트너로 인식해야 한다.

메시지를 수신한 객체는 **메서드**를 실행해 요청에 응답한다. 여기서 객체가 메시지를 처리할 방법을 **스스로 선택한다**는 점이 중요하다. **외부의 객체는 오직 메시지만 전송할 수 있을 뿐이며 메시지를 어떻게 처리할지는 메시지를 수신한 객체가 직접 결정한다.** 이것은 객체가 자신의 일을 스스로 처리할 수 있는 자율적인 존재라는 것을 의미한다.

<img width="600" alt="Screening" src="https://github.com/ESC-CoM/esc-client/assets/62797441/cb69c53b-2295-4950-8f63-b64557791dd1" />

Screening이 Movie에게 처리를 위임하는 이유는 요금을 계산하는 데 필요한 기본 요금과 할인 정책을 가장 잘 알고 있는 객체가 Movie이기 때문이다. 요금을 계산하는 작업을 Screening이 수행한다면 Movie의 인스턴스 변수인 fee, discountPolicy에 직접 접근해야만 한다. 이 경우 Screening은 Movie의 내부 구현에 결합된다.

가장 큰 문제점은 Movie의 자율성이 훼손된다는 것이다. 자율적인 객체란 자신의 상태를 직접 관리하고 스스로의 결정에 따라 행동하는 객체다. 객체의 자율성을 보장하기 위해서는 필요한 정보와 정보에 기반한 행동을 같은 객체 안에 모아놓아야 한다. but Screeing이 Movie의 정보를 이용해 요금을 계산할 경우 정보와 행동이 Movie, Screening이라는 별도의 객체로 나뉜다. 결과적으로 Movie는 자율적인 존재가 아니라 수동적인 존재로 전락하고 만다.

Movie가 자율적인 존재가 되기 위해서는 자신이 알고 있는 정보를 이용해 직접 요금을 계산해야 한다. 이것이 Screening이 Movie에게 요금을 계산하도록 위임하는 이유다. 자신이 할 수 없는 일을 다른 객체에게 위임하면 협력에 참여하는 객체들의 전체적인 자율성을 향상시킬 수 있다.

결과적으로 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 **캡슐화**하는 것이다. 캡슐화를 통해 변경에 대한 파급효과를 제한할 수 있기 때문에 자율적인 객체는 변경하기도 쉬워진다. Movie가 자신의 정보를 바탕으로 요금을 직접 계산하면 Screening과 Movie 사이의 결합도를 느슨하게 유지할 수 있으며 Movie에 대한 변경의 여파가 Screening 쪽으로 확산되는 것을 막을 수 있다.
 
자율적인 객체는 자신에게 할당된 책임을 수행하던 중에 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 적절한 객체에게 메시지를 전송해서 협력을 요청한다. 메시지를 수신한 객체 역시 메시지를 처리하던 중에 직접 처리할 수 없는 정보나 행동이 필요한 경우 또 다른 객체에게 도움을 요청한다. 이처럼 객체들 사이의 협력을 구성하는 일련의 요청과 응답의 흐름을 통해 애플리케이션의 기능이 구현된다.

## 협력이 설계를 위한 문맥을 결정한다.
어떤 객체도 섬이 아니다. 애플리케이션 안에 어떤 객체가 필요하다면 그 이유는 단 하나여야 한다. 그 객체가 어떤 협력에 참여하고 있기 때문이다. 그리고 객체가 협력에 참여할 수 있는 이유는 협력에 필요한 적절한 행동을 보유하고 있기 때문이다.

결론적으로 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다. 협력이 바뀌면 객체가 제공해야 하는 행동 역시 바뀌어야 한다. 협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공한다.

Movie의 행동을 결정하는 것은 영화 예매를 위한 협력이다. 협력이라는 문맥을 고려하지 않고 Movie의 행동을 결정하는 것은 아무런 의미가 없다. 협력이 존재하기 때문에 객체가 존재하는 것이다.

**객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동이다.** 객체의 상태는 그 객체가 행동을 수행하는 데 필요한 정보가 무엇인지로 결정된다. 객체는 자신의 상태를 스스로 결정하고 관리하는 자율적인 존재이기 때문에 객체가 수행하는 행동에 필요한 상태도 함께 가지고 있어야 한다.

상태는 객체가 행동하는 데 필요한 정보에 의해 결정되고 행동은 협력 안에서 객체가 처리할 메시지로 결정된다. 결과적으로 객체가 참여하는 협력이 객체를 구성하는 행동과 상태 모두를 결정한다. 따라서 협력은 객체를 설계하는 데 필요한 일종의 문맥(context)을 제공한다.

# 7장 연산자
연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리 ,타입, 지수 연산 등을 수행해 하나의 값을 만든다. 이때 연산의 대상을 피연산자라 한다. **피연산자는 값으로 평가될 수 있어야 한다. 그리고 피연산자와 연산자의 조합으로 이뤄진 연산자 표현식도 값으로 평가될 수 있는 표현식이다.**

``` js
true && false // false
typeof 'hi' // string
```

피연산자가 **값**이라는 명사의 역할을 한다면 연산자는 **피연산자를 연산하여 새로운 값을 만든다**라는 동사 역할을 한다고 볼 수 있다. 값으로 평가된 피연산자를 연산해 새로운 값을 만든다.

## 7.1.2 단항 산술 연산자
++, -- 는 증가, 감소인데 **사이드 이펙트**를 가지고 있다. **피연산자의 값을 변경하기 때문이다.** 증가/감소 연산을 하면 피연산자의 값을 변경하는 **암묵적 할당**이 이뤄진다.

또한, 위치에 의미가 있다. `먼저 피연산자의 값을 증가/감소 vs 먼저 다른 연산 후 피연산자 값을 증가/감소`

+, - 단항 연산자를 사용하면 피연산자를 **숫자 타입으로 변환하여 반환한다.** `이때, 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 따라서 사이드 이펙트는 없다.`

``` js
-'Hello' // NaN
-true // -1
-'10' // -10
```

## 7.1.3 문자열 연결 연산자
+ 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.
``` js
1 + true // 2
1 + false // 1
1 + null // 1
+undefined // NaN
1 + undefined // NaN
```

이때 개발자의 의도와는 상관없이 JS 엔진에 의해 암묵적으로 타입이 자동 변환하기도 한다. 1 + true를 연산하면 JS 엔진은 암묵적으로 불리언 타입의 값인 true를 숫자 타입인 1로 타입을 강제로 변환한 후 연산을 수행한다.

이를 **암묵적 타입 변환** 또는 **타입 강제 변환**이라고 한다. 앞서 살펴본 +,- 단항 연산자도 암묵적 타입 변환이 발생한 것이다.

## 7.2 할당 연산자
=, +=, -=, *=, /=, &= 등, 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수 효과(다른 코드에 영향을 준다.)가 있다.

표현식은 값으로 평가될 수 있는 문이고, 문에는 표현식인 문, 표현식이 아닌 문이 있다. `할당문은 표현식인 문이다.`

`console.log(x = 10); // 10`
할당문은 변수에 값을 할당하는 부수 효과만 있을 뿐 값으로 평가되지 않을 것처럼 보인다. 하지만 할당문은 **값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.** 위 예제 할당문은 x에 할당된 숫자 값 10으로 평가된다. 따라서 할당문을 다른 변수에 할당할 수도 있다.
`a = b = c = 0`

## 7.3 비교 연산자
==, ===, !=, !==, 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.

**동등 비교 연산자(==)는 좌항, 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.**

``` js
5 === 5 // true
5 == '5' // true

'0' == '' // false
0 == '' // true
0 == '0' // true
false == 'false' // false
false == '0' // true
false == null // false
false == undefined // false
```
동등 비교 연산자는 예측하기 어려운 결과를 만들어 낸다. 따라서 일치 비교(===)연산자를 사용하는 것이 좋다. **암묵적 타입 변환을 하지 않고 값을 비교한다.** 따라서 일치 비교 연산자는 예측하기 쉽다.

`NaN === NaN` false, 자신과 일치하지 않는 유일한 값이다. 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 Number.isNaN을 사용한다.

``` js
Number.isNan(NaN) // true
Number.isNaN(1 + undefined) // true
```

``` js
0 === -0 // true
0 == -0 // true
```

**Object.is 메소드**<br />
예측 가능한 정확한 비교 결과를 반환한다. 그 외에는 일치 비교 연산자와 동일하게 동작한다.

``` js
Object.is(-0, +0) // false
Object.is(NaN, NaN) // true
```

## 7.5 논리 연산자
||, &&, !

``` js
true || true // true
true || false // true
false || true // true
false || false // false

true && true // true
true && false // false
```

논리 부정(!) 연산자는 언제나 **boolean**값을 반환한다. 단, 피연산자가 반드시 불리언 값일 필요는 없다. **피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환된다.**

``` js
!0 // true
!'Hello' // false
```

논리합(||), 논리곱(&&) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.

``` js
// 단축 평가 -> 9장
'Cat' && 'Dog' // Dog
```

## 7.6 쉽표 연산자
왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.

``` js
var x, y, z;
x = 1, y = 2, z = 3 // 3
```

## 7.8 typeof
``` js
typeof '' // string
typeof 1 // number
typeof NaN // number
typeof true // boolean
typeof undefined // undefined
typeof Symbol() // symbol
typeof null // object
typeof [] // object
typeof {} // object
typeof new Date() // object
typeof /test/gi // object
typeof function() {} // function
```

null에 주의해야 한다. 
``` js
var foo = null;

typeof foo === null // false
foo === null // true

// undeclared 식별자를 선언한 적이 없다. ReferenceError가 발생하지 않고 undefined 반환한다.
typeof undeclared; // undefined
```

## 7.9 지수 연산자
`2**2` // 4
`Math.pow(2, 2)` // 4

음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호를 묶어야 한다.
`(-5) ** 2` // 25

이항 연산자 중에서 우선순위가 가장 높다.

## 7.10 그 외의 연산자
1. ?. : 옵셔널 체이닝 연산자
2. ?? : null 병합 연산자
3. delete : 프로퍼티 삭제
4. new : 생성자 함수를 호출할 때 사용하여 인스턴스 생성
5. instanceof : 좌편의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별
6. in : 프로퍼티 존재 확인

## 연산자 우선순위
1. ()
2. new(매개변수 O), [](프로퍼티 접근), ()(함수 호출), ?.(옵셔녈 체이닝 연산자)
3. new(매개변수 X)
4. x++, x--
5. !x, +x, -x, ++x, --x, typeof, delete
6. **(이항 연산자 중에서 가장 높다.)
7. *, /, %
8. +, -
9. <, <=, >, >=, in, instanceof
10. ==, !=, ===, !==
11. ??
12. &&
13. ||
14. 삼항 연산자
15. 할당 연산자(=, +=, -=)
16. ,

연산자가 너무 많아서 기억하기 힘드므로 연산자 우선순위가 높은 그룹 연산자를 사용하여 우선순위를 명시적으로 조절하는 것을 권장한다.
